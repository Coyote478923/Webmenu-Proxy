// index.js
const SCRIPT_URL = "https://raw.githubusercontent.com/<you>/<repo>/main/webmenu2.js"; // set to your hosted script URL

addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const url = new URL(request.url);
  const target = url.searchParams.get('url');
  if (!target) {
    return new Response('Usage: ?url=https://example.com', { status: 400 });
  }

  // Build fetch options; forward method/headers where sensible
  const fetchOpts = { method: 'GET', redirect: 'manual', headers: {} };
  // Pass along a simple UA to avoid some blocking
  fetchOpts.headers['User-Agent'] = request.headers.get('User-Agent') || 'Mozilla/5.0 (Cloudflare Worker)';

  let res;
  try {
    res = await fetch(target, fetchOpts);
  } catch (err) {
    return new Response('Fetch error: ' + err.message, { status: 502 });
  }

  // If not HTML, proxy the response directly (images, CSS, JS, etc.)
  const contentType = res.headers.get('content-type') || '';
  if (!contentType.includes('text/html')) {
    // Copy headers but strip hop-by-hop headers
    const headers = filterResponseHeaders(res.headers);
    return new Response(res.body, { status: res.status, headers });
  }

  // Load HTML text
  let html;
  try {
    html = await res.text();
  } catch (e) {
    return new Response('Error reading HTML', { status: 500 });
  }

  // Remove meta CSP tags from HTML (so injected script can run)
  html = html.replace(/<meta[^>]*http-equiv=["']?content-security-policy["']?[^>]*>/gi, '');

  // Inject script tag before </body> (case-insensitive). Use external SCRIPT_URL so CSP bypass is easier.
  const injectTag = `<script src="${SCRIPT_URL}"></script>`;
  if (html.search(/<\/body>/i) !== -1) {
    html = html.replace(/<\/body>/i, injectTag + '</body>');
  } else {
    html += injectTag;
  }

  // Build response headers: copy original, but remove CSP headers which would block injection
  const headers = filterResponseHeaders(res.headers);
  headers.delete('content-security-policy');
  headers.delete('x-content-security-policy');
  headers.delete('x-webkit-csp');

  // Ensure we serve HTML
  headers.set('content-type', 'text/html; charset=UTF-8');

  return new Response(html, { status: res.status, headers });
}

function filterResponseHeaders(origHeaders) {
  const headers = new Headers();
  for (const [k, v] of origHeaders.entries()) {
    const lk = k.toLowerCase();
    // strip hop-by-hop or security headers we will handle
    if (['content-encoding','transfer-encoding','content-security-policy','x-content-security-policy','x-webkit-csp','set-cookie'].includes(lk)) continue;
    headers.set(k, v);
  }
  // Allow framing and others if you want; adjust as needed
  return headers;
}
